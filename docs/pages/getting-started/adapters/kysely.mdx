import { Callout } from "nextra/components"
import { Code } from "@/components/Code"

<img align="right" src="/img/adapters/kysely.svg" width="64" height="64" />

# Kysely 适配器

## 相关资源

- [Kysely 文档](https://kysely.dev/docs/intro)

## 配置

### 安装

```bash npm2yarn
npm install kysely @auth/kysely-adapter
```

### 环境变量

```sh
DATABASE_HOST=
DATABASE_NAME=
DATABASE_USER=
DATABASE_PASSWORD=
```

### 配置

该适配器支持与 Kysely (截至 v0.24.2 版本)相同的官方方言：PostgreSQL、MySQL 和 SQLite。以下示例使用 PostgreSQL 配合 [pg](https://www.npmjs.com/package/pg) 客户端。

```bash npm2yarn
npm install pg
npm install --save-dev @types/pg
```

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import { KyselyAdapter } from "@auth/kysely-adapter"
import { db } from "../../../db"

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: KyselyAdapter(db),
  providers: [],
})
```

</Code.Next>
<Code.Qwik>

```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import { KyselyAdapter } from "@auth/kysely-adapter"
import { db } from "../../../db"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [],
    adapter: KyselyAdapter(db),
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import { KyselyAdapter } from "@auth/kysely-adapter"
import { db } from "../../../db"

export const { handle, signIn, signOut } = SvelteKitAuth({
  adapter: KyselyAdapter(db),
  providers: [],
})
```

</Code.Svelte>
<Code.Express>

```ts filename="./src/routes/auth.route.ts"
import { ExpressAuth } from "@auth/express"
import { KyselyAdapter } from "@auth/kysely-adapter"
import { db } from "../../../db"

const app = express()

app.set("trust proxy", true)
app.use(
  "/auth/*",
  ExpressAuth({
    providers: [],
    adapter: KyselyAdapter(db),
  })
)
```

</Code.Express>
</Code>

Kysely 的构造函数需要一个数据库接口，其中包含每个表的接口条目。您可以手动定义这些类型，或使用 `kysely-codegen` / `prisma-kysely` 自动生成它们。请查阅 Auth.js 所需的默认[模型](/guides/creating-a-database-adapter)。

```ts filename="db.ts"
import { PostgresDialect } from "kysely"
import { Pool } from "pg"

// This adapter exports a wrapper of the original `Kysely` class called `KyselyAuth`,
// that can be used to provide additional type-safety.
// While using it isn't required, it is recommended as it will verify
// that the database interface has all the fields that Auth.js expects.
import { KyselyAuth } from "@auth/kysely-adapter"

import type { GeneratedAlways } from "kysely"

interface Database {
  User: {
    id: GeneratedAlways<string>
    name: string | null
    email: string
    emailVerified: Date | null
    image: string | null
  }
  Account: {
    id: GeneratedAlways<string>
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }
  Session: {
    id: GeneratedAlways<string>
    userId: string
    sessionToken: string
    expires: Date
  }
  VerificationToken: {
    identifier: string
    token: string
    expires: Date
  }
}

export const db = new KyselyAuth<Database>({
  dialect: new PostgresDialect({
    pool: new Pool({
      host: process.env.DATABASE_HOST,
      database: process.env.DATABASE_NAME,
      user: process.env.DATABASE_USER,
      password: process.env.DATABASE_PASSWORD,
    }),
  }),
})
```

<Callout>
手动定义类型的替代方案是使用 [kysely-codegen](https://github.com/RobinBlomberg/kysely-codegen) 从数据库模式生成类型，或使用 [prisma-kysely](https://github.com/valtyr/prisma-kysely) 从 Prisma 模式生成。当与 `KyselyAuth` 一起使用生成类型时，导入 `Codegen` 并将其作为第二个泛型参数传递：

```ts
import type { Codegen } from "@auth/kysely-adapter"
new KyselyAuth<Database, Codegen>()
```

</Callout>

### 数据库模式

```ts filename="db/migrations/001_create_db.ts"
import { Kysely, sql } from "kysely"

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .createTable("User")
    .addColumn("id", "uuid", (col) =>
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn("name", "text")
    .addColumn("email", "text", (col) => col.unique().notNull())
    .addColumn("emailVerified", "timestamptz")
    .addColumn("image", "text")
    .execute()

  await db.schema
    .createTable("Account")
    .addColumn("id", "uuid", (col) =>
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn("userId", "uuid", (col) =>
      col.references("User.id").onDelete("cascade").notNull()
    )
    .addColumn("type", "text", (col) => col.notNull())
    .addColumn("provider", "text", (col) => col.notNull())
    .addColumn("providerAccountId", "text", (col) => col.notNull())
    .addColumn("refresh_token", "text")
    .addColumn("access_token", "text")
    .addColumn("expires_at", "bigint")
    .addColumn("token_type", "text")
    .addColumn("scope", "text")
    .addColumn("id_token", "text")
    .addColumn("session_state", "text")
    .execute()

  await db.schema
    .createTable("Session")
    .addColumn("id", "uuid", (col) =>
      col.primaryKey().defaultTo(sql`gen_random_uuid()`)
    )
    .addColumn("userId", "uuid", (col) =>
      col.references("User.id").onDelete("cascade").notNull()
    )
    .addColumn("sessionToken", "text", (col) => col.notNull().unique())
    .addColumn("expires", "timestamptz", (col) => col.notNull())
    .execute()

  await db.schema
    .createTable("VerificationToken")
    .addColumn("identifier", "text", (col) => col.notNull())
    .addColumn("token", "text", (col) => col.notNull().unique())
    .addColumn("expires", "timestamptz", (col) => col.notNull())
    .execute()

  await db.schema
    .createIndex("Account_userId_index")
    .on("Account")
    .column("userId")
    .execute()

  await db.schema
    .createIndex("Session_userId_index")
    .on("Session")
    .column("userId")
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.dropTable("Account").ifExists().execute()
  await db.schema.dropTable("Session").ifExists().execute()
  await db.schema.dropTable("User").ifExists().execute()
  await db.schema.dropTable("VerificationToken").ifExists().execute()
}
```

> 此模式已适配用于 Kysely，并基于我们的主[模式](/reference/core/adapters#models)。

有关使用 Kysely 创建和运行迁移的更多信息，请参阅 [Kysely 迁移文档](https://kysely.dev/docs/migrations)。

### 命名约定

如果混合使用 snake_case 和 camelCase 列名对您或底层数据库系统造成困扰，我们推荐使用 Kysely 的 `CamelCasePlugin` 功能（[查看文档](https://kysely-org.github.io/kysely-apidoc/classes/CamelCasePlugin.html)）来修改字段命名。这不会影响 NextAuth.js，但能让您在使用 Kysely 时保持命名风格的一致性。
