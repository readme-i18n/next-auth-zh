import { Callout } from "nextra/components"
import { Code } from "@/components/Code"
import { Accordion, Accordions } from "@/components/Accordion"

<img align="right" src="/img/adapters/prisma.svg" width="64" height="64" />

# Prisma 适配器

## 相关资源

- [Prisma 文档](https://www.prisma.io/docs)

## 配置

### 安装

```bash npm2yarn
npm install @prisma/client @auth/prisma-adapter
npm install prisma --save-dev
```

### 环境变量

Prisma 需要设置环境变量来建立与数据库的连接并获取数据。Prisma 要求使用 `DATABASE_URL` 环境变量来创建连接。更多信息请参阅[文档](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-postgresql)。

```sh
DATABASE_URL=postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA
```

### 配置

为了在使用 `Prisma ORM` 时提升性能，我们可以设置 Prisma 实例以确保整个项目中只创建一个实例，然后根据需要从任何文件导入。这种方法避免了每次使用时都重新创建 PrismaClient 实例。最后，我们可以从 `auth.ts` 配置文件导入 Prisma 实例。

```ts filename="prisma.ts"
import { PrismaClient } from "@prisma/client"

const globalForPrisma = globalThis as unknown as { prisma: PrismaClient }

export const prisma = globalForPrisma.prisma || new PrismaClient()

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma
```

<Callout type="warning">
  如果使用中间件或其他边缘运行时，我们推荐使用 `@prisma/client@5.12.0`
  或更高版本。更多信息请参阅下方的[边缘兼容性](#edge-compatibility)部分。
</Callout>

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { prisma } from "@/prisma"

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: PrismaAdapter(prisma),
  providers: [],
})
```

</Code.Next>
<Code.Qwik>

```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { prisma } from "@/prisma"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [],
    adapter: PrismaAdapter(prisma),
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { prisma } from "@/prisma"

export const { handle, signIn, signOut } = SvelteKitAuth({
  adapter: PrismaAdapter(prisma),
  providers: [],
})
```

</Code.Svelte>
<Code.Express>

```ts filename="./src/routes/auth.route.ts"
import { ExpressAuth } from "@auth/express"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { prisma } from "@/prisma"

const app = express()

app.set("trust proxy", true)
app.use(
  "/auth/*",
  ExpressAuth({
    providers: [],
    adapter: PrismaAdapter(prisma),
  })
)
```

</Code.Express>
</Code>

### 边缘兼容性

Prisma 已在 `5.12.0` 版本中为其客户端提供了边缘运行时支持。您可以通过他们的[边缘文档](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview)了解更多详情。该功能需要特定的数据库驱动支持，因此仅兼容部分数据库类型/托管服务提供商。开始使用前请查阅他们的[支持驱动列表](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview#which-database-drivers-are-edge-compatible)。您可以在[此处](https://github.com/ndom91/authjs-prisma-edge-example)查看一个结合 `next-auth` 和 Prisma 的边缘运行时 Auth.js 应用示例。

关于边缘兼容性的更多通用信息，请参阅我们的[边缘兼容性指南](/guides/edge-compatibility)。

原始数据库边缘运行时的变通方案（即将 `auth.ts` 配置拆分为两部分的方法）仍保留在下方。

#### 旧版边缘解决方案

目前 Prisma 仍在完善对 Vercel 等边缘运行时的全面兼容性。相关进展可追踪[此议题](https://github.com/prisma/prisma/issues/20560)，Prisma 在 `5.9.1` 版本的[更新日志](https://github.com/prisma/prisma/releases/tag/5.9.0)中宣布了早期边缘支持。现有两种解决方案应对此问题：

- 使用 Prisma 的 [Accelerate](https://pris.ly/d/accelerate) 功能
- 按照我们的 [Edge 兼容性指南](/guides/edge-compatibility) 作为临时解决方案。该方法采用 `jwt` 会话策略，并将 `auth.ts` 配置拆分为两个文件。

在 Prisma 使用 `jwt` 会话策略且版本为 `@prisma/client@5.9.1` 或更高时，除确保不在中间件执行数据库查询外，无需额外修改。

自 `@prisma/client@5.9.1` 起，Prisma 不再在实例化时抛出与 edge 运行时兼容性相关的错误，而是在查询时抛出。因此只要不在中间件中执行查询操作，即可在中间件使用的文件中导入 Prisma。

### 数据库模式

需使用 Prisma `2.26.0` 或更高版本。在 `prisma/schema.prisma` 路径下创建包含以下模型的架构文件。

<Accordions>
<Accordion title="PostgreSQL">

```prisma filename="prisma/schema-postgres.prisma"
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String          @id @default(cuid())
  name          String?
  email         String          @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}
```

</Accordion>
<Accordion title="MySQL">

```prisma filename="prisma/schema-mysql.prisma"
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String          @id @default(cuid())
  name          String?
  username      String?         @unique
  email         String?         @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                       String  @id @default(cuid())
  userId                   String  @unique
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String? @db.Text
  access_token             String? @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String? @db.Text
  session_state            String?
  refresh_token_expires_in Int?
  user                     User?   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}
```

<Callout>
  When using the MySQL connector for Prisma, the [Prisma `String`
  type](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string)
  gets mapped to `varchar(191)` which may not be long enough to store fields
  such as `id_token` in the `Account` model. This can be avoided by explicitly
  using the `Text` type with `@db.Text` as shown for some fields in the example
  above.
</Callout>

</Accordion>
<Accordion title="SQLite">

```prisma filename="prisma/schema-sqlite.prisma"
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String          @id @default(cuid())
  name          String?
  email         String?         @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}
```

</Accordion>
<Accordion title="MongoDB">

```prisma filename="prisma/schema-mongodb.prisma"
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String          @id @default(auto()) @map("_id") @db.ObjectId
  name          String?
  email         String?         @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @id @map("_id")
  userId               String  @db.ObjectId
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, credentialID])
}
```

Prisma supports MongoDB, and so does Auth.js. Following the instructions of the [Prisma documentation](https://www.prisma.io/docs/concepts/database-connectors/mongodb) on the MongoDB connector, things to look out for include the following.

1. Make sure that the id fields are mapped correctly

```prisma
id  String  @id @default(auto()) @map("_id") @db.ObjectId
```

2. Use the native database type attributes like `@db.String` and for Id fields, `@db.ObjectId`.

```prisma
user_id            String   @db.ObjectId
refresh_token      String?  @db.String
access_token       String?  @db.String
id_token           String?  @db.String
```

This has all been applied in the above example schema already.

</Accordion>
</Accordions>

### 应用数据模型

此操作将创建 SQL 迁移文件并执行：

```bash npm2yarn
npm exec prisma migrate dev
```

注意需在环境变量 `DATABASE_URL` 中指定数据库连接字符串。可通过在项目根目录的 `.env` 文件中设置该变量实现。

### 生成 Prisma 客户端

`prisma migrate dev` 命令也会生成 Prisma 客户端，但如需手动重新生成，可运行以下命令。

```bash npm2yarn
npm exec prisma generate
```

### 开发流程

在开发应用程序并修改数据库架构时，每次对架构进行更改后都需要重新运行迁移命令，以便 Prisma 能够：(1) 生成迁移文件并将其应用到基础数据库；(2) 使用最新的类型和模型方法重新生成项目中的 Prisma 客户端。

```bash npm2yarn
npm exec prisma migrate dev
```

### 命名规范

如果混合使用 `snake_case` 和 `camelCase` 列名对您或底层数据库系统造成困扰，我们建议使用 Prisma 的 [`@map()` 功能](https://www.prisma.io/docs/concepts/components/prisma-schema/names-in-underlying-database)来更改字段名称。这不会影响 Auth.js，但允许您将列名自定义为任何偏好的命名规范。

例如，迁移到使用 `snake_case` 和复数表名。

```prisma filename="schema.prisma"
model Account {
  id                 String  @id @default(cuid())
  userId             String  @map("user_id")
  type               String
  provider           String
  providerAccountId  String  @map("provider_account_id")
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  accounts      Account[]
  sessions      Session[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
```
