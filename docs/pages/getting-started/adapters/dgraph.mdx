import { Callout } from "nextra/components"
import { Code } from "@/components/Code"

<img align="right" src="/img/adapters/dgraph.svg" width="64" height="64" />

# Dgraph 适配器

## 相关资源

- [Dgraph 文档](https://dgraph.io/docs)

## 配置

### 安装

```bash npm2yarn
npm install @auth/dgraph-adapter
```

### 环境变量

```sh
AUTH_DGRAPH_GRAPHQL_ENDPOINT=http://localhost:8080/graphql
AUTH_DGRAPH_GRAPHQL_KEY=abc123
```

### 配置

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import { DgraphAdapter } from "@auth/dgraph-adapter"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [],
  adapter: DgraphAdapter({
    endpoint: process.env.AUTH_DGRAPH_GRAPHQL_ENDPOINT,
    authToken: process.env.AUTH_DGRAPH_GRAPHQL_KEY,
    // you can omit the following properties if you are running an unsecure schema
    authHeader: process.env.AUTH_HEADER, // default: "Authorization",
    jwtSecret: process.env.AUTH_SECRET,
  }),
})
```

</Code.Next>
<Code.Qwik>

```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import { DgraphAdapter } from "@auth/dgraph-adapter"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [],
    adapter: DgraphAdapter({
      endpoint: import.meta.env.DGRAPH_GRAPHQL_ENDPOINT,
      authToken: import.meta.env.DGRAPH_GRAPHQL_KEY,
      // you can omit the following properties if you are running an unsecure schema
      authHeader: import.meta.env.AUTH_HEADER, // default: "Authorization",
      jwtSecret: import.meta.env.SECRET,
    }),
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import { DgraphAdapter } from "@auth/dgraph-adapter"

export const { handle, signIn, signOut } = SvelteKitAuth({
  providers: [],
  adapter: DgraphAdapter({
    endpoint: process.env.DGRAPH_GRAPHQL_ENDPOINT,
    authToken: process.env.DGRAPH_GRAPHQL_KEY,
    // you can omit the following properties if you are running an unsecure schema
    authHeader: process.env.AUTH_HEADER, // default: "Authorization",
    jwtSecret: process.env.SECRET,
  }),
})
```

</Code.Svelte>
<Code.Express>

```ts filename="./src/routes/auth.route.ts"
import { ExpressAuth } from "@auth/express"
import { DgraphAdapter } from "@auth/dgraph-adapter"

const app = express()

app.set("trust proxy", true)
app.use(
  "/auth/*",
  ExpressAuth({
    providers: [],
    adapter: DgraphAdapter({
      endpoint: process.env.DGRAPH_GRAPHQL_ENDPOINT,
      authToken: process.env.DGRAPH_GRAPHQL_KEY,
      // you can omit the following properties if you are running an unsecure schema
      authHeader: process.env.AUTH_HEADER, // default: "Authorization",
      jwtSecret: process.env.SECRET,
    }),
  })
)
```

</Code.Express>
</Code>

### 非安全模式

使用 Dgraph 的最快方式是将非安全模式应用到您的[本地](https://dgraph.io/docs/graphql/admin/#modifying-a-schema) Dgraph 实例，如果使用 Dgraph [云服务](https://dgraph.io/docs/cloud/cloud-quick-start/#the-schema)，您可以将模式粘贴到代码框中以更新。

<Callout type="warning">
  此方法不安全且不适用于生产环境，且不需要 `jwtSecret`。
</Callout>

> 此模式已适配用于 Dgraph，并基于我们的主要[模式](https://authjs.dev/reference/core/adapters)

#### 示例

```graphql
type Account {
  id: ID
  type: String
  provider: String @search(by: [hash])
  providerAccountId: String @search(by: [hash])
  refreshToken: String
  expires_at: Int64
  accessToken: String
  token_type: String
  refresh_token: String
  access_token: String
  scope: String
  id_token: String
  session_state: String
  user: User @hasInverse(field: "accounts")
}
type Session {
  id: ID
  expires: DateTime
  sessionToken: String @search(by: [hash])
  user: User @hasInverse(field: "sessions")
}
type User {
  id: ID
  name: String
  email: String @search(by: [hash])
  emailVerified: DateTime
  image: String
  accounts: [Account] @hasInverse(field: "user")
  sessions: [Session] @hasInverse(field: "user")
}

type VerificationToken {
  id: ID
  identifier: String @search(by: [hash])
  token: String @search(by: [hash])
  expires: DateTime
}
```

### 安全模式

对于生产部署，您需要限制对 next-auth 使用的类型的访问。Dgraph 中主要的访问控制形式是通过 `@auth` 指令与模式中的类型一起使用。

#### 示例

```graphql
type Account
  @auth(
    delete: { rule: "{$nextAuth: { eq: true } }" }
    add: { rule: "{$nextAuth: { eq: true } }" }
    query: { rule: "{$nextAuth: { eq: true } }" }
    update: { rule: "{$nextAuth: { eq: true } }" }
  ) {
  id: ID
  type: String
  provider: String @search(by: [hash])
  providerAccountId: String @search(by: [hash])
  refreshToken: String
  expires_at: Int64
  accessToken: String
  token_type: String
  refresh_token: String
  access_token: String
  scope: String
  id_token: String
  session_state: String
  user: User @hasInverse(field: "accounts")
}
type Session
  @auth(
    delete: { rule: "{$nextAuth: { eq: true } }" }
    add: { rule: "{$nextAuth: { eq: true } }" }
    query: { rule: "{$nextAuth: { eq: true } }" }
    update: { rule: "{$nextAuth: { eq: true } }" }
  ) {
  id: ID
  expires: DateTime
  sessionToken: String @search(by: [hash])
  user: User @hasInverse(field: "sessions")
}
type User
  @auth(
    query: {
      or: [
        {
          rule: """
          query ($userId: String!) {queryUser(filter: { id: { eq: $userId } } ) {id}}
          """
        }
        { rule: "{$nextAuth: { eq: true } }" }
      ]
    }
    delete: { rule: "{$nextAuth: { eq: true } }" }
    add: { rule: "{$nextAuth: { eq: true } }" }
    update: {
      or: [
        {
          rule: """
          query ($userId: String!) {queryUser(filter: { id: { eq: $userId } } ) {id}}
          """
        }
        { rule: "{$nextAuth: { eq: true } }" }
      ]
    }
  ) {
  id: ID
  name: String
  email: String @search(by: [hash])
  emailVerified: DateTime
  image: String
  accounts: [Account] @hasInverse(field: "user")
  sessions: [Session] @hasInverse(field: "user")
}

type VerificationToken
  @auth(
    delete: { rule: "{$nextAuth: { eq: true } }" }
    add: { rule: "{$nextAuth: { eq: true } }" }
    query: { rule: "{$nextAuth: { eq: true } }" }
    update: { rule: "{$nextAuth: { eq: true } }" }
  ) {
  id: ID
  identifier: String @search(by: [hash])
  token: String @search(by: [hash])
  expires: DateTime
}

# Dgraph.Authorization {"VerificationKey":"<YOUR JWT SECRET HERE>","Header":"<YOUR AUTH HEADER HERE>","Namespace":"<YOUR CUSTOM NAMESPACE HERE>","Algo":"HS256"}
```

### Dgraph.Authorization

为了保护您的 graphql 后端，请在模式底部定义 `Dgraph.Authorization` 对象，并向 DgraphClient 提供 `authHeader` 和 `jwtSecret` 值。

```js
# Dgraph.Authorization {"VerificationKey":"<YOUR JWT SECRET HERE>","Header":"<YOUR AUTH HEADER HERE>","Namespace":"YOUR CUSTOM NAMESPACE HERE","Algo":"HS256"}
```

### VerificationKey 和 jwtSecret

这是用于签署 JWT 的密钥。例如 `process.env.SECRET` 或 `process.env.APP_SECRET`。

### Header 和 authHeader

`Header` 用于指示 Dgraph 在传入服务器的请求头中查找 JWT 的位置。
您需要在 schema 文件底部配置该头部，此头部与实例化 `DgraphClient` 时提供的 `authHeader` 属性相同。

### nextAuth 密钥

`$nextAuth` 密钥通过 `jwtSecret` 安全生成，并由 DgraphAdapter 注入，以便系统内匿名用户请求（如登录、注册）能够与 JWT DgraphClient 交互。这使得 next-auth 所需的所有认证类型都能进行安全交互。您需要在安全 schema 中为每种类型定义的每个认证规则指定该密钥。

```js
type VerificationRequest
  @auth(
    delete: { rule: "{$nextAuth: { eq: true } }" },
    add: { rule: "{$nextAuth: { eq: true } }" },
    query: { rule: "{$nextAuth: { eq: true } }" },
    update: { rule: "{$nextAuth: { eq: true } }" }
  ) {
}
```

### JWT 会话与 `@auth` 指令

Dgraph 仅支持 HS256 或 RS256 算法。若需使用会话 JWT 安全连接 dgraph 数据库，必须自定义 next-auth 的 `encode` 和 `decode` 函数，因为默认算法为 HS512。您还可以通过角色进一步定制 JWT，以实现 [`RBAC 逻辑`](https://dgraph.io/docs/graphql/authorization/directive/#role-based-access-control)。

```js filename="./auth.js"
import NextAuth from "next-auth"
import * as jwt from "jsonwebtoken"

export const { handlers, auth, signIn, signOut } = NextAuth({
  session: {
    strategy: "jwt",
  },
  jwt: {
    secret: process.env.SECRET,
    encode: async ({ secret, token }) => {
      return jwt.sign({ ...token, userId: token.id }, secret, {
        algorithm: "HS256",
        expiresIn: 30 * 24 * 60 * 60, // 30 days
      })
    },
    decode: async ({ secret, token }) => {
      return jwt.verify(token, secret, { algorithms: ["HS256"] })
    },
  },
})
```

在 schema 中定义 `Dgraph.Authorization` 并设置 JWT 参数后，即可为 schema 的每个部分定义 [`@auth 规则`](https://dgraph.io/docs/graphql/authorization/authorization-overview/)。
