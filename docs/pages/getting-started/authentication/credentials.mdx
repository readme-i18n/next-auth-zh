---
title: 凭证认证
---

import { Steps, Callout } from "nextra/components"
import { Code } from "@/components/Code"

# 凭证认证

要通过外部认证机制或传统用户名/邮箱密码流程配置Auth.js，我们可以使用`Credentials`提供者。该提供者设计用于将登录表单中提交的任何凭证（如用户名/密码，但不限于此）转发至您的认证服务。

<Callout type="warning">
  自用户名密码成为Web应用用户认证授权的默认机制以来，行业已取得长足进步。因此，如有可能，我们推荐采用更现代安全的认证机制，例如[OAuth提供者](/getting-started/authentication/oauth)、[邮件魔法链接](/getting-started/authentication/email)或[WebAuthn(通行密钥)](/getting-started/authentication/webauthn)等方案。

但我们同样希望保持灵活性，支持您认为适合应用场景的任何方案，因此暂无移除该提供者的计划。

</Callout>

<Callout>
  默认情况下，Credentials提供者不会在数据库中持久化数据。但您仍可在数据库中创建和保存任何数据，只需提供必要的逻辑，例如加密密码、添加速率限制、实现密码重置功能等。
</Callout>

<Steps>

### Credentials Provider

要使用 `Credentials Provider`，首先需要在 `Auth.js` 配置中导入并设置它。该提供程序允许您基于表单输入值实现自定义登录逻辑。

配置步骤如下：

1. 导入提供程序
2. 将其添加到 `Auth.js` 配置的 `providers` 数组中
3. 定义 `credentials` 和 `authorize` 字段

#### `credentials`

`credentials` 对象定义了默认登录页面上显示的输入字段。这些输入会自动渲染在以下路由：

- `/api/auth/signin` (Next.js)
- `/auth/signin` (其他框架)

每个字段接受以下属性：

- `label`: 输入标签
- `type`: HTML 输入类型 (`text`, `password` 等)
- `placeholder`: 占位文本

> 这些字段也会作为 `credentials` 参数传递给 `authorize` 函数。

更多细节请参阅 [内置页面指南](https://authjs.dev/guides/pages/built-in-pages)。

```ts
Credentials({
  credentials: {
    email: {
      type: "email",
      label: "Email",
      placeholder: "johndoe@gmail.com",
    },
    password: {
      type: "password",
      label: "Password",
      placeholder: "*****",
    },
  },
})
```

#### `authorize`

`authorize` 函数处理自定义登录逻辑，判断提供的凭据是否有效。

它会接收 `credentials` 中定义的输入值，您必须返回一个用户对象或 `null`。如果返回 `null`，则登录失败。

<Code>
<Code.Next>

```ts filename="./auth.ts" {2, 8}
import NextAuth from "next-auth"
import Credentials from "next-auth/providers/credentials"
// 处理明文密码的自定义逻辑，请谨慎操作！
import { saltAndHashPassword } from "@/utils/password"

export const { handlers, signIn, signOut, auth } = NextAuth({
  providers: [
    Credentials({
      // 您可以通过在 `credentials` 对象中添加键来指定应提交的字段
      // 例如 domain, username, password, 2FA token 等
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        let user = null

        // 密码加盐和哈希处理逻辑
        const pwHash = saltAndHashPassword(credentials.password)

        // 验证用户是否存在的逻辑
        user = await getUserFromDb(credentials.email, pwHash)

        if (!user) {
          // 未找到用户，这是首次登录尝试
          // 可选地，这里也可以进行用户注册
          throw new Error("Invalid credentials.")
        }

        // 返回包含用户资料数据的对象
        return user
      },
    }),
  ],
})
```

</Code.Next>
<Code.Qwik>
  
```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import Credentials from "@auth/qwik/providers/credentials"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [
      Credentials({
        credentials: {
          email: { label: "Email" },
          password: { label: "Password", type: "password" },
        },
        async authorize(credentials) {
          const response = await getUserFromDb(credentials)
          if (!response.ok) return null
          return (await response.json()) ?? null
        },
      }),
    ],
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts" {2, 8}
import { SvelteKitAuth } from "@auth/sveltekit"
import Credentials from "@auth/sveltekit/providers/credentials"
// 处理明文密码的自定义逻辑，请谨慎操作！
import { saltAndHashPassword } from "@/utils/password"

export const { signIn, signOut, handle } = SvelteKitAuth({
  providers: [
    Credentials({
      // 您可以通过在 `credentials` 对象中添加键来指定应提交的字段
      // 例如 domain, username, password, 2FA token 等
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        let user = null

        // 密码加盐和哈希处理逻辑
        const pwHash = saltAndHashPassword(credentials.password)

        // 验证用户是否存在的逻辑
        user = await getUserFromDb(credentials.email, pwHash)

        if (!user) {
          // 未找到用户，这是首次登录尝试
          // 可选地，这里也可以进行用户注册
          throw new Error("Invalid credentials.")
        }

        // 返回包含用户数据的 JSON 对象
        return user
      },
    }),
  ],
})
```

别忘了在 `./src/hooks.server.ts` 文件中重新导出 `handle`。

```ts filename="./src/hooks.server.ts"
export { handle } from "./auth"
```

</Code.Svelte>

<Code.Express>

```ts filename="./src/routes/auth.route.ts" {2, 11}
import { ExpressAuth } from "@auth/express"
import Credentials from "@auth/express/providers/credentials"
import express from "express"
// 处理明文密码的自定义逻辑，请谨慎操作！
import { saltAndHashPassword } from "@/utils/password"

const app = express()
app.use(
  "/auth/*",
  ExpressAuth({
    providers: [
      Credentials({
        // 您可以通过在 `credentials` 对象中添加键来指定应提交的字段
        // 例如 domain, username, password, 2FA token 等
        credentials: {
          email: {},
          password: {},
        },
        authorize: async (credentials) => {
          let user = null

          // 密码加盐和哈希处理逻辑
          const pwHash = saltAndHashPassword(credentials.password)

          // 验证用户是否存在的逻辑
          user = await getUserFromDb(credentials.email, pwHash)

          if (!user) {
            // 未找到用户，这是首次登录尝试
            // 可选地，这里也可以进行用户注册
            throw new Error("Invalid credentials.")
          }

          // 返回包含用户资料数据的对象
          return user
        },
      }),
    ],
  })
)
```

</Code.Express>
</Code>

<Callout type="info">
  如果您使用 TypeScript，可以[扩展 `User`
  接口](/getting-started/typescript#module-augmentation)以匹配 `authorize`
  回调的响应， 这样当您在其他回调(如 `jwt`)中读取用户时，类型将正确匹配。
</Callout>

### 登录表单

最后，让我们创建一个简单的登录表单。

<Code>
<Code.Next>

```tsx filename="./components/sign-in.tsx" {13, 17} /formData/
import { signIn } from "@/auth"

export function SignIn() {
  return (
    <form
      action={async (formData) => {
        "use server"
        await signIn("credentials", formData)
      }}
    >
      <label>
        Email
        <input name="email" type="email" />
      </label>
      <label>
        密码
        <input name="password" type="password" />
      </label>
      <button>登录</button>
    </form>
  )
}
```

</Code.Next>
<Code.NextClient>

```tsx filename="./components/sign-in.tsx"
"use client"
import { signIn } from "next-auth/react"

export function SignIn() {
  const credentialsAction = (formData: FormData) => {
    signIn("credentials", formData)
  }

  return (
    <form action={credentialsAction}>
      <label htmlFor="credentials-email">
        Email
        <input type="email" id="credentials-email" name="email" />
      </label>
      <label htmlFor="credentials-password">
        密码
        <input type="password" id="credentials-password" name="password" />
      </label>
      <input type="submit" value="登录" />
    </form>
  )
}
```

</Code.NextClient>
<Code.Qwik>

```ts filename="/src/routes/index.tsx"
import { component$ } from "@builder.io/qwik"
import { Form } from "@builder.io/qwik-city"
import { useSignIn } from "./plugin@auth"

export default component$(() => {
  const signInSig = useSignIn()

  return (
    <Form action={signInSig}>
      <label>
        Email
        <input name="email" type="email" />
      </label>
      <label>
        密码
        <input name="password" type="password" />
      </label>
      <button>登录</button>
    </Form>
  )
})
```

</Code.Qwik>
<Code.Svelte>

```svelte filename="src/route/+page.svelte" /bind:value/ /signIn/
<script>
  import { signIn } from "../auth"
  import { page } from "$app/stores"

  let email = ""
  let password = ""
</script>

<div>
  <form>
    <label>
      Email
      <input name="email" type="email" bind:value={email} />
    </label>
    <label>
      密码
      <input name="password" type="password" bind:value={password} />
    </label>
    <button on:click={() => signIn("credentials", { email, password })}>
      登录
    </button>
  </form>
</div>
```

</Code.Svelte>

<Code.Express>

```html filename="views/signin.html"
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>登录</title>
  </head>
  <body>
    <h1>登录</h1>
    <form action="/auth/signin" method="POST">
      <label for="email">Email:</label>
      <input type="email" name="email" id="email" required />
      <br />
      <label for="password">密码:</label>
      <input type="password" name="password" id="password" required />
      <br />
      <button type="submit">登录</button>
    </form>
  </body>
</html>
```

</Code.Express>

</Code>

</Steps>

## 凭证验证

务必在服务端验证凭证，例如使用 [Zod](https://zod.dev) 这类模式验证库。

```bash npm2yarn
npm install zod
```

接下来我们将在 `auth.ts` 配置文件中设置模式和解析逻辑，通过 `Credentials` 提供者的 `authorize` 回调实现。

<Code>
<Code.Next>

```ts filename="./lib/zod.ts"
import { object, string } from "zod"

export const signInSchema = object({
  email: string({ required_error: "Email is required" })
    .min(1, "Email is required")
    .email("Invalid email"),
  password: string({ required_error: "Password is required" })
    .min(1, "Password is required")
    .min(8, "Password must be more than 8 characters")
    .max(32, "Password must be less than 32 characters"),
})
```

```ts filename="./auth.ts" {22}
import NextAuth from "next-auth"
import { ZodError } from "zod"
import Credentials from "next-auth/providers/credentials"
import { signInSchema } from "./lib/zod"
// Your own logic for dealing with plaintext password strings; be careful!
import { saltAndHashPassword } from "@/utils/password"
import { getUserFromDb } from "@/utils/db"

export const { handlers, auth } = NextAuth({
  providers: [
    Credentials({
      // You can specify which fields should be submitted, by adding keys to the `credentials` object.
      // e.g. domain, username, password, 2FA token, etc.
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        try {
          let user = null

          const { email, password } = await signInSchema.parseAsync(credentials)

          // logic to salt and hash password
          const pwHash = saltAndHashPassword(password)

          // logic to verify if the user exists
          user = await getUserFromDb(email, pwHash)

          if (!user) {
            throw new Error("Invalid credentials.")
          }

          // return JSON object with the user data
          return user
        } catch (error) {
          if (error instanceof ZodError) {
            // Return `null` to indicate that the credentials are invalid
            return null
          }
        }
      },
    }),
  ],
})
```

</Code.Next>
<Code.Qwik>

```ts filename="./lib/zod.ts"
import { object, string } from "zod"

export const signInSchema = object({
  email: string({ required_error: "Email is required" })
    .min(1, "Email is required")
    .email("Invalid email"),
  password: string({ required_error: "Password is required" })
    .min(1, "Password is required")
    .min(8, "Password must be more than 8 characters")
    .max(32, "Password must be less than 32 characters"),
})
```

```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import Credentials from "@auth/qwik/providers/credentials"
import { signInSchema } from "./lib/zod"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [
      Credentials({
        credentials: {
          email: { label: "Email" },
          password: { label: "Password", type: "password" },
        },
        async authorize(credentials) {
          const { email, password } = await signInSchema.parseAsync(credentials)

          // Your logic here
        },
      }),
    ],
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./lib/zod.ts"
import { object, string } from "zod"

export const signInSchema = object({
  email: string({ required_error: "Email is required" })
    .min(1, "Email is required")
    .email("Invalid email"),
  password: string({ required_error: "Password is required" })
    .min(1, "Password is required")
    .min(8, "Password must be more than 8 characters")
    .max(32, "Password must be less than 32 characters"),
})
```

```ts filename="./auth.ts" {22-23}
import SvelteKitAuth from "@auth/sveltekit"
import { ZodError } from "zod"
import Credentials from "@auth/sveltekit/providers/credentials"
import { signInSchema } from "./lib/zod"
// Your own logic for dealing with plaintext password strings; be careful!
import { saltAndHashPassword } from "@/utils/password"
import { getUserFromDb } from "@/utils/db"

export const { handle } = SvelteKitAuth({
  providers: [
    Credentials({
      // You can specify which fields should be submitted, by adding keys to the `credentials` object.
      // e.g. domain, username, password, 2FA token, etc.
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        try {
          let user = null

          const { email, password } =
            await createUserSchema.parseAsync(credentials)

          // logic to salt and hash password
          const pwHash = saltAndHashPassword(password)

          // logic to verify if the user exists
          user = await getUserFromDb(email, pwHash)

          if (!user) {
            throw new Error("Invalid credentials.")
          }

          // return JSON object with the user data
          return user
        } catch (error) {
          if (error instanceof ZodError) {
            // Return `null` to indicate that the credentials are invalid
            return null
          }
        }
      },
    }),
  ],
})
```

</Code.Svelte>
</Code>

<Callout>

当 authorize 返回 null 时，Auth.js 会通过以下两种方式之一处理错误：

使用内置页面时：

- 用户将被重定向至登录页面，并附带查询字符串：`?error=CredentialsSignin&code=credentials`。可通过 [credentials provider options](https://authjs.dev/reference/core/providers/credentials#returns) 自定义错误代码。
- 使用表单操作或自定义错误处理（如在 Remix、SvelteKit 中）：错误会以 credentialssignin 形式抛出，必须在服务端操作中手动捕获。详见 [Auth.js 错误参考](https://authjs.dev/reference/core/errors#credentialssignin)。

</Callout>
