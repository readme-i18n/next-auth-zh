import { Callout, Tabs } from "nextra/components"
import { Code } from "@/components/Code"

<img
  align="right"
  src="/img/providers/forwardemail.svg"
  className="dark:bg-[currentColor]"
  height="64"
  width="96"
/>

# Forward Email 邮件转发服务提供商

## 概述

Forward Email 提供商通过电子邮件发送包含验证令牌 URL 的"魔法链接"，可用于登录。

在支持 OAuth 服务登录的同时增加邮件登录方式，为用户在无法访问 OAuth 账户时（例如账户被锁定或删除）提供了备用登录途径。

Forward Email 提供商可以单独使用，也可以与一个或多个 OAuth 提供商配合使用。

### 工作原理

首次登录时，系统会向提供的邮箱地址发送一个**验证令牌**。默认情况下该令牌有效期为 24 小时。若在此期间使用了验证令牌（即点击邮件中的链接），系统将为用户创建账户并完成登录。

如果用户使用*已存在账户*的邮箱地址登录，系统会发送邮件，当用户点击邮件中的链接时即可登录与该邮箱关联的账户。

<Callout type="warning">
  Forward Email 提供商既支持 BasicAuth
  也支持数据库管理的会话，但**必须配置数据库**才能使用该服务。不使用数据库的情况下无法启用邮件登录功能。
</Callout>

## 配置

1. 首先，您需要将域名[添加到 Forward Email 账户](https://forwardemail.net/my-account/domains)。这是 Forward Email 的必要步骤，该域名将作为您在 `from` 提供者选项中使用的地址域名。

2. 接下来，您需要在[我的账户 → 安全设置](https://forwardemail.net/my-account/security)中生成 API 密钥。可将此 API 密钥保存为 `AUTH_FORWARDEMAIL_KEY` 环境变量。

```sh
AUTH_FORWARDEMAIL_KEY=abc
```

若将环境变量命名为 `AUTH_FORWARDEMAIL_KEY`，提供者会自动识别该变量，从而简化 Auth.js 配置对象。如需自定义变量名，则需在 Auth.js 配置中手动传递给提供者。

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import ForwardEmail from "next-auth/providers/forwardemail"

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: ...,
  providers: [
    ForwardEmail({
      // If your environment variable is named differently than default
      apiKey: AUTH_FORWARDEMAIL_KEY,
      from: "no-reply@company.com"
    }),
  ],
})
```

</Code.Next>
<Code.Qwik>

```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import ForwardEmail from "@auth/qwik/providers/forwardemail"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [
      ForwardEmail({
        // If your environment variable is named differently than default
        apiKey: import.meta.env.AUTH_FORWARDEMAIL_KEY,
        from: "no-reply@company.com",
      }),
    ],
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import ForwardEmail from "@auth/sveltekit/providers/forwardemail"
import { env } from "$env/dynamic/prviate"

export const { handle, signIn, signOut } = SvelteKitAuth({
  adapter: ...,
  providers: [
    ForwardEmail({
      // If your environment variable is named differently than default
      apiKey: env.AUTH_FORWARDEMAIL_KEY,
      from: "no-reply@company.com",
    }),
  ],
})
```

</Code.Svelte>
</Code>

4. 请勿忘记设置[数据库适配器](https://authjs.dev/getting-started/database)用于存储邮件验证令牌。

5. 现在您可以通过 `/api/auth/signin` 发起电子邮件地址登录流程。

用户账户（即 `Users` 表中的条目）将在首次验证邮件地址后创建。若邮件地址已关联现有账户，用户点击魔法链接邮件中的链接并使用验证令牌后，将直接登录该账户。

## 自定义配置

### 邮件正文

您可以通过向 `ForwardEmail()` 传递 `sendVerificationRequest` 选项的自定义函数，完全定制发送的登录邮件内容。

```js {7} filename="./auth.ts"
import NextAuth from "next-auth"
import ForwardEmail from "next-auth/providers/forwardemail"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    ForwardEmail({
      server: process.env.EMAIL_SERVER,
      from: process.env.EMAIL_FROM,
      sendVerificationRequest({
        identifier: email,
        url,
        provider: { server, from },
      }) {
        // your function
      },
    }),
  ],
})
```

以下示例展示了我们内置的 `sendVerificationRequest()` 方法的源代码。请注意，我们在此方法中渲染 HTML (`html()`) 并通过网络调用 (`fetch()`) 实际执行 Forward Email 的发送操作。

```ts filename="./lib/authSendRequest.ts" {4, 14}
export async function sendVerificationRequest(params) {
  const { identifier: to, provider, url, theme } = params
  const { host } = new URL(url)
  const res = await fetch("https://api.forwardemail.net/v1/emails", {
    method: "POST",
    headers: {
      Authorization: `Basic ${btoa(provider.apiKey + ":")}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      from: provider.from,
      to,
      subject: `Sign in to ${host}`,
      html: html({ url, host, theme }),
      text: text({ url, host }),
    }),
  })

  if (!res.ok)
    throw new Error("Forward Email error: " + JSON.stringify(await res.json()))
}

function html(params: { url: string; host: string; theme: Theme }) {
  const { url, host, theme } = params

  const escapedHost = host.replace(/\./g, "&#8203;.")

  const brandColor = theme.brandColor || "#346df1"
  const color = {
    background: "#f9f9f9",
    text: "#444",
    mainBackground: "#fff",
    buttonBackground: brandColor,
    buttonBorder: brandColor,
    buttonText: theme.buttonText || "#fff",
  }

  return `
<body style="background: ${color.background};">
  <table width="100%" border="0" cellspacing="20" cellpadding="0"
    style="background: ${color.mainBackground}; max-width: 600px; margin: auto; border-radius: 10px;">
    <tr>
      <td align="center"
        style="padding: 10px 0px; font-size: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};">
        Sign in to <strong>${escapedHost}</strong>
      </td>
    </tr>
    <tr>
      <td align="center" style="padding: 20px 0;">
        <table border="0" cellspacing="0" cellpadding="0">
          <tr>
            <td align="center" style="border-radius: 5px;" bgcolor="${color.buttonBackground}"><a href="${url}"
                target="_blank"
                style="font-size: 18px; font-family: Helvetica, Arial, sans-serif; color: ${color.buttonText}; text-decoration: none; border-radius: 5px; padding: 10px 20px; border: 1px solid ${color.buttonBorder}; display: inline-block; font-weight: bold;">Sign
                in</a></td>
          </tr>
        </table>
      </td>
    </tr>
    <tr>
      <td align="center"
        style="padding: 0px 0px 10px 0px; font-size: 16px; line-height: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};">
        If you did not request this email you can safely ignore it.
      </td>
    </tr>
  </table>
</body>
`
}

// Email Text body (fallback for email clients that don't render HTML, e.g. feature phones)
function text({ url, host }: { url: string; host: string }) {
  return `Sign in to ${host}\n${url}\n\n`
}
```

<Callout type="info">
  如需生成兼容多种邮件客户端的精美 React 邮件模板，请查看
  [mjml](https://mjml.io) 或 [react-email](https://react.email)
</Callout>

### 验证令牌

默认情况下，我们会生成随机验证令牌。如需自定义生成逻辑，可在提供者选项中定义 `generateVerificationToken` 方法：

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import ForwardEmail from "next-auth/providers/forwardemail"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    ForwardEmail({
      async generateVerificationToken() {
        return crypto.randomUUID()
      },
    }),
  ],
})
```

### 邮箱地址规范化

Auth.js 默认会对邮箱地址进行规范化处理：将地址视为大小写不敏感（虽然技术上不符合 [RFC 2821 规范](https://datatracker.ietf.org/doc/html/rfc2821)，但实际应用中强制区分大小写会导致更多问题，例如从数据库查询用户邮箱时），并移除可能以逗号分隔形式传入的次要邮箱地址。您可以通过 `ForwardEmail` 提供者的 `normalizeIdentifier` 方法实现自定义规范化。以下示例展示了默认行为：

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import ForwardEmail from "next-auth/providers/forwardemail"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    ForwardEmail({
      normalizeIdentifier(identifier: string): string {
        // Get the first two elements only,
        // separated by `@` from user input.
        let [local, domain] = identifier.toLowerCase().trim().split("@")
        // The part before "@" can contain a ","
        // but we remove it on the domain part
        domain = domain.split(",")[0]
        return `${local}@${domain}`

        // You can also throw an error, which will redirect the user
        // to the sign-in page with error=EmailSignin in the URL
        // if (identifier.split("@").length > 2) {
        //   throw new Error("Only one email allowed")
        // }
      },
    }),
  ],
})
```

<Callout type="warning">
  务必确保该方法始终返回单个邮箱地址，即使传入了多个地址。
</Callout>
