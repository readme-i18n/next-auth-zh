import { Callout, Steps } from "nextra/components"
import { Code } from "@/components/Code"
import { Accordion, Accordions } from "@/components/Accordion"

<img align="right" src="/img/providers/passkey.svg" width="128" height="128" />

# 通行密钥

## 配置

<Callout type="warning">
  WebAuthn / 通行密钥提供程序目前处于实验阶段，不建议在生产环境中使用。
</Callout>

通行密钥提供程序**需要数据库适配器**以及该数据库中的新表。请参阅适配器的文档页面以获取相应的迁移详细信息。

目前以下适配器/框架包支持通行密钥。

| 包名称                    | 最低版本        | 链接                                        |
| ------------------------- | --------------- | ------------------------------------------- |
| `next-auth`               | `5.0.0-beta.17` |                                             |
| `@auth/sveltekit`         | `1.0.2`         |                                             |
| `@auth/prisma-adapter`    | `1.3.3`         | [文档](/getting-started/adapters/prisma)    |
| `@auth/unstorage-adapter` | `2.1.0`         | [文档](/getting-started/adapters/unstorage) |
| `@auth/drizzle-adapter`   | `1.1.1`         | [文档](/getting-started/adapters/drizzle)   |

<Steps>
### 安装 peer 依赖项

```bash npm2yarn
npm install @simplewebauthn/browser@9.0.1 @simplewebauthn/server@9.0.3
```

`@simplewebauthn/browser` peer 依赖项仅在使用自定义登录页面时需要。如果使用 Auth.js 默认页面，可以跳过安装该 peer 依赖项。

### 数据库设置

Passkeys 提供程序需要一个额外的 `Authenticator` 表。目前多个适配器已支持 Passkeys，具体迁移步骤请参阅各自的文档页面。以下以 Prisma 为例，同时也提供了原始 SQL 迁移方案。

<Accordions>
<Accordion title="Prisma 模式">

```prisma {18, 54-66}
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  Authenticator Authenticator[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}

model Authenticator {
  id                   String  @id @default(cuid())
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

  </Accordion>
  <Accordion title="SQL 迁移">

此迁移适用于 **PostgreSQL** 和 **SQLite**。

```sql filename="./migration/add-webauthn-authenticator-table-postgres.sql"
-- CreateTable
CREATE TABLE "Authenticator" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "credentialID" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "credentialPublicKey" TEXT NOT NULL,
    "counter" INTEGER NOT NULL,
    "credentialDeviceType" TEXT NOT NULL,
    "credentialBackedUp" BOOLEAN NOT NULL,
    "transports" TEXT,
    CONSTRAINT "Authenticator_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "Authenticator_credentialID_key" ON "Authenticator"("credentialID");
```

此迁移适用于 **MySQL** / **MariaDB**。

```sql filename="./migration/add-webauthn-authenticator-table-mysql.sql"
-- CreateTable
CREATE TABLE Authenticator (
    id varchar(255) NOT NULL PRIMARY KEY,
    credentialID TEXT NOT NULL,
    userId varchar(255) NOT NULL,
    providerAccountId TEXT NOT NULL,
    credentialPublicKey TEXT NOT NULL,
    counter INTEGER NOT NULL,
    credentialDeviceType TEXT NOT NULL,
    credentialBackedUp BOOLEAN NOT NULL,
    transports TEXT,
    CONSTRAINT Authenticator_userId_fkey FOREIGN KEY (userId) REFERENCES User (id) ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX Authenticator_credentialID_key ON Authenticator(credentialID);
```

  </Accordion>
  </Accordions>

#### 边缘兼容性

如果在 Next.js 和中间件中使用 `next-auth`，需确保所选数据库客户端具有"边缘兼容性"。若使用旧版 Prisma 或其他不兼容的适配器，需进行调整。详见 [边缘兼容性](/guides/edge-compatibility) 指南。[Prisma 适配器文档](/getting-started/adapters/prisma#edge-compatibility) 中也有 Prisma 相关说明。

### 更新 Auth.js 配置

将 `Passkey` 提供程序添加到配置中，并确保使用兼容的数据库适配器。同时需要显式启用实验性 WebAuthn 功能。

```ts filename="./auth.ts" {10}
import Passkey from "next-auth/providers/passkey"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient()

export default {
  adapter: PrismaAdapter(prisma),
  providers: [Passkey],
  experimental: { enableWebAuthn: true },
}
```

如果使用 Auth.js 内置页面，现在已完成配置！访问 `/signin` 路由应能看到"使用 Passkeys 登录"按钮。

### 自定义页面

如果构建自定义登录页面，可以使用 `next-auth/webauthn` 的 `signIn` 函数来启动 WebAuthn 注册和认证流程。注意：使用 WebAuthn `signIn` 函数时需要安装 `@simplewebauth/browser` peer 依赖项。

```ts filename="app/login/page.tsx" {4} /webauthn/
"use client"

import { useSession } from "next-auth/react"
import { signIn } from "next-auth/webauthn"

export default function Login() {
  const { data: session, update, status } = useSession()

  return (
    <div>
      {status === "authenticated" ? (
        <button onClick={() => signIn("passkey", { action: "register" })}>
          注册新 Passkey
        </button>
      ) : status === "unauthenticated" ? (
        <button onClick={() => signIn("passkey")}>使用 Passkey 登录</button>
      ) : null}
    </div>
  )
}
```

</Steps>

## 选项

您可以在 [API 参考文档](/reference/core/providers/webauthn#webauthnconfig) 中找到所有 Passkeys 提供商的配置选项。
