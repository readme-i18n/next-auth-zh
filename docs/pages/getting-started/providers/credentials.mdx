import { Callout } from "nextra/components"
import { Code } from "@/components/Code"

# 凭证认证提供程序

Credentials 提供程序允许您处理任意凭证的登录流程，例如用户名密码组合、域名、双因素认证或硬件设备（如 YubiKey U2F/FIDO）。

该方案适用于需要对现有系统进行用户认证的场景，因此通过此方式认证的用户信息不会持久化存储在数据库中。

## 相关资源

- [客户端输入验证示例](/getting-started/authentication/credentials#verifying-data-with-zod)

## 配置

<Code>
  <Code.Next>

```ts filename="/auth.ts"
import NextAuth from "next-auth"
import Credentials from "next-auth/providers/credentials"

export const { signIn, signOut, auth } = NextAuth({
  providers: [
    Credentials({
      credentials: {
        username: { label: "Username" },
        password: { label: "Password", type: "password" },
      },
      async authorize({ request }) {
        const response = await fetch(request)
        if (!response.ok) return null
        return (await response.json()) ?? null
      },
    }),
  ],
})
```

  </Code.Next>
  <Code.Qwik>
  
```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import Credentials from "@auth/qwik/providers/credentials"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [
      Credentials({
        credentials: {
          username: { label: "Username" },
          password: { label: "Password", type: "password" },
        },
        async authorize({ request }) {
          const response = await fetch(request)
          if (!response.ok) return null
          return (await response.json()) ?? null
        },
      }),
    ],
  })
)
```

  </Code.Qwik>
  <Code.Svelte>

```ts filename="/src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import Credentials from "@auth/sveltekit/providers/credentials"

export const { handle, signIn, signOut } = SvelteKitAuth({
  providers: [
    Credentials({
      credentials: {
        username: { label: "Username" },
        password: { label: "Password", type: "password" },
      },
      async authorize({ request }) {
        const response = await fetch(request)
        if (!response.ok) return null
        return (await response.json()) ?? null
      },
    }),
  ],
})
```

  </Code.Svelte>
  <Code.Express>

```ts filename="/src/app.ts"
import { ExpressAuth } from "@auth/express";
import Credentials from "@auth/express/providers/credentials";

app.use("/auth/*", ExpressAuth({
  providers: [
    Credentials({
      credentials: {
        username: { label: "Username" },
        password: { label: "Password", type: "password" },
      },
      async authorize({ request }) {
        const response = await fetch(request);
        if (!response.ok) return null;
        return (await response.json()) ?? null;
      },
    }),
  ],
});
```

  </Code.Express>
</Code>

### 自定义错误消息

您可以在 `authorize` 函数中抛出定制错误，向用户返回特定的错误提示信息。

```ts filename="@/auth.ts" /InvalidLoginError/
import NextAuth, { CredentialsSignin } from "next-auth"
import Credentials from "next-auth/providers/credentials"

class InvalidLoginError extends CredentialsSignin {
  code = "Invalid identifier or password"
}

export const { handlers, auth } = NextAuth({
  providers: [
    Credentials({
      credentials: {
        username: { label: "Username" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        throw new InvalidLoginError()
      },
    }),
  ],
})
```

当用户登录失败返回登录页面时，您将在 URL 查询参数中接收到该错误代码，例如 `https://app.company.com/auth/signin?error=CredentialsSignin&code=Invalid+identifier+password`。

<Callout type="warning">
OAuth 提供商投入了大量资金、时间和工程资源来构建：

- 滥用检测（机器人防护、速率限制）
- 密码管理（密码重置、凭证填充、轮换）
- 数据安全（加密/加盐、强度验证）

以及更多认证解决方案。您的应用程序很可能会受益于利用这些经过实战检验的解决方案，而不是从头开始重建它们。

如果您仍然希望为应用程序构建基于密码的身份验证（尽管存在这些风险），Auth.js 为您提供了完全控制权来实现这一目标。

</Callout>
