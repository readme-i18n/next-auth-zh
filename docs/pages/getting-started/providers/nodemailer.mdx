import { Callout, Tabs } from "nextra/components"
import { Code } from "@/components/Code"

<img align="right" src="/img/providers/nodemailer.svg" height="64" width="96" />

# Nodemailer 邮件服务提供商

## 概述

Nodemailer 提供商通过电子邮件发送包含验证令牌 URL 的"魔法链接"，可用于登录。

在支持 OAuth 服务登录的同时增加邮件登录方式，为用户在无法访问 OAuth 账户时（例如账户被锁定或删除）提供了备用登录途径。

Nodemailer 提供商可以单独使用，也可以与一个或多个 OAuth 提供商配合使用。

### 工作原理

首次登录时，系统会向提供的邮箱地址发送一个**验证令牌**。默认情况下该令牌有效期为 24 小时。若在此期间使用了验证令牌（即点击邮件中的链接），系统将为用户创建账户并完成登录。

如果用户使用*已存在账户*的邮箱地址登录，系统会发送邮件，当用户点击邮件中的链接时即可登录与该邮箱关联的账户。

<Callout type="warning">
  Nodemailer 提供商同时支持 JSON Web Token
  和数据库管理的会话，但**必须配置数据库**才能使用。不使用数据库的情况下无法启用电子邮件登录功能。
</Callout>

## 配置

1. Auth.js 不包含 `nodemailer` 作为依赖项，如需使用 Nodemailer 提供商，需自行安装。

```bash npm2yarn
npm install nodemailer
```

2. 需要准备一个 SMTP 账户，最好选择[已知与 `nodemailer` 兼容的服务](https://community.nodemailer.com/2-0-0-beta/setup-smtp/well-known-services/)。Nodemailer 也支持[其他传输方式](https://nodemailer.com/transports/)，但如果要使用基于 HTTP 的邮件服务，建议改用专为此设计的其他 Auth.js 提供商，如 [Resend](/getting-started/providers/resend) 或 [Sendgrid](/getting-started/providers/sendgrid)。

3. 配置 SMTP 服务器连接有两种方式。

可以使用连接字符串或 `nodemailer` 配置对象。

<Tabs items={['Connection string', 'Configuration object']}>
  <Tabs.Tab>

```bash filename=".env"
EMAIL_SERVER=smtp://username:password@smtp.example.com:587
EMAIL_FROM=noreply@example.com
```

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Nodemailer from "next-auth/providers/nodemailer"

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: ...,
  providers: [
    Nodemailer({
      server: process.env.EMAIL_SERVER,
      from: process.env.EMAIL_FROM,
    }),
  ],
})
```

</Code.Next>
<Code.Qwik>
  
```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import Nodemailer from "@auth/qwik/providers/nodemailer"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [
      Nodemailer({
        server: import.meta.env.EMAIL_SERVER,
        from: import.meta.env.EMAIL_FROM,
      }),
    ],
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import Nodemailer from "@auth/sveltekit/providers/nodemailer"
import { env } from "$env/dynamic/prviate"

export const { handle, signIn, signOut } = SvelteKitAuth({
  adapter: ...,
  providers: [
    Nodemailer({
      server: env.EMAIL_SERVER,
      from: env.EMAIL_FROM,
    }),
  ],
})
```

```ts filename="src/hooks.server.ts"
export { handle } from "./auth"
```

</Code.Svelte>
</Code>

  </Tabs.Tab>
  <Tabs.Tab>

```bash filename=".env"
EMAIL_SERVER_USER=username
EMAIL_SERVER_PASSWORD=password
EMAIL_SERVER_HOST=smtp.example.com
EMAIL_SERVER_PORT=587
EMAIL_FROM=noreply@example.com
```

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Nodemailer from "next-auth/providers/nodemailer"

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: ...,
  providers: [
    Nodemailer({
      server: {
        host: process.env.EMAIL_SERVER_HOST,
        port: process.env.EMAIL_SERVER_PORT,
        auth: {
          user: process.env.EMAIL_SERVER_USER,
          pass: process.env.EMAIL_SERVER_PASSWORD,
        },
      },
      from: process.env.EMAIL_FROM,
    }),
  ],
})
```

</Code.Next>
<Code.Svelte>

```ts filename="./src/auth.ts"
import { SvelteKitAuth } from "@auth/sveltekit"
import Nodemailer from "@auth/sveltekit/providers/nodemailer"
import { env } from "$env/dynamic/prviate"

export const { handle, signIn, signOut } = SvelteKitAuth({
  adapter: ...,
  providers: [
    Nodemailer({
      server: {
        host: env.EMAIL_SERVER_HOST,
        port: env.EMAIL_SERVER_PORT,
        auth: {
          user: env.EMAIL_SERVER_USER,
          pass: env.EMAIL_SERVER_PASSWORD,
        },
      },
      from: env.EMAIL_FROM,
    }),
  ],
})
```

</Code.Svelte>
</Code>

  </Tabs.Tab>
</Tabs>

4. 请勿忘记设置数据库[适配器](https://authjs.dev/reference/core/adapters)用于存储邮箱验证令牌。

5. 现在您可以在`/api/auth/signin`通过邮箱地址发起登录流程。

在用户首次验证邮箱地址之前，系统不会为其创建用户账户（即`Users`表中的记录）。若邮箱地址已关联现有账户，用户通过邮件链接登录时将直接进入该账户。

## 自定义配置

### 邮件正文

您可以通过向`Nodemailer()`传递`sendVerificationRequest`选项的自定义函数，完全定制发送的登录验证邮件。

```ts {7} filename="./auth.ts"
import NextAuth from "next-auth"
import Nodemailer from "next-auth/providers/nodemailer"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    Nodemailer({
      server: process.env.EMAIL_SERVER,
      from: process.env.EMAIL_FROM,
      sendVerificationRequest({
        identifier: email,
        url,
        provider: { server, from },
      }) {
        // your function
      },
    }),
  ],
})
```

以下示例展示了内置`sendVerificationRequest()`方法的源码。请注意，我们在此方法中同时处理了HTML渲染(`html()`)和通过邮件服务商发送邮件的网络调用(`transport.sendMail()`)。

```ts {8, 13}
import { createTransport } from "nodemailer"

export async function sendVerificationRequest(params) {
  const { identifier, url, provider, theme } = params
  const { host } = new URL(url)
  // NOTE: You are not required to use `nodemailer`, use whatever you want.
  const transport = createTransport(provider.server)
  const result = await transport.sendMail({
    to: identifier,
    from: provider.from,
    subject: `Sign in to ${host}`,
    text: text({ url, host }),
    html: html({ url, host, theme }),
  })
  const failed = result.rejected.concat(result.pending).filter(Boolean)
  if (failed.length) {
    throw new Error(`Email(s) (${failed.join(", ")}) could not be sent`)
  }
}

function html(params: { url: string; host: string; theme: Theme }) {
  const { url, host, theme } = params

  const escapedHost = host.replace(/\./g, "&#8203;.")

  const brandColor = theme.brandColor || "#346df1"
  const color = {
    background: "#f9f9f9",
    text: "#444",
    mainBackground: "#fff",
    buttonBackground: brandColor,
    buttonBorder: brandColor,
    buttonText: theme.buttonText || "#fff",
  }

  return `
<body style="background: ${color.background};">
  <table width="100%" border="0" cellspacing="20" cellpadding="0"
    style="background: ${color.mainBackground}; max-width: 600px; margin: auto; border-radius: 10px;">
    <tr>
      <td align="center"
        style="padding: 10px 0px; font-size: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};">
        Sign in to <strong>${escapedHost}</strong>
      </td>
    </tr>
    <tr>
      <td align="center" style="padding: 20px 0;">
        <table border="0" cellspacing="0" cellpadding="0">
          <tr>
            <td align="center" style="border-radius: 5px;" bgcolor="${color.buttonBackground}"><a href="${url}"
                target="_blank"
                style="font-size: 18px; font-family: Helvetica, Arial, sans-serif; color: ${color.buttonText}; text-decoration: none; border-radius: 5px; padding: 10px 20px; border: 1px solid ${color.buttonBorder}; display: inline-block; font-weight: bold;">Sign
                in</a></td>
          </tr>
        </table>
      </td>
    </tr>
    <tr>
      <td align="center"
        style="padding: 0px 0px 10px 0px; font-size: 16px; line-height: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};">
        If you did not request this email you can safely ignore it.
      </td>
    </tr>
  </table>
</body>
`
}

// Email Text body (fallback for email clients that don't render HTML, e.g. feature phones)
function text({ url, host }: { url: string; host: string }) {
  return `Sign in to ${host}\n${url}\n\n`
}
```

<Callout type="info">
  如需生成兼容多种邮件客户端的精美 React 邮件模板，请查看
  [mjml](https://mjml.io) 或 [react-email](https://react.email)
</Callout>

### 验证令牌

默认情况下，我们会生成随机验证令牌。如需自定义生成逻辑，可在提供者选项中定义 `generateVerificationToken` 方法：

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Nodemailer from "next-auth/providers/nodemailer"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    Nodemailer({
      async generateVerificationToken() {
        return crypto.randomUUID()
      },
    }),
  ],
})
```

### 邮箱地址规范化

默认情况下，Auth.js会对电子邮件地址进行规范化处理。它将地址视为不区分大小写（虽然从技术上讲这不符合[RFC 2821规范](https://datatracker.ietf.org/doc/html/rfc2821)，但在实际应用中，严格执行规范反而会引发更多问题，例如从数据库中通过电子邮件查找用户时）。同时，系统还会移除可能以逗号分隔列表形式传入的任何次要电子邮件地址。您可以通过`Nodemailer`提供商的`normalizeIdentifier`方法应用自定义的规范化处理。以下示例展示了默认行为：

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Nodemailer from "next-auth/providers/nodemailer"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    Nodemailer({
      normalizeIdentifier(identifier: string): string {
        // Get the first two elements only,
        // separated by `@` from user input.
        let [local, domain] = identifier.toLowerCase().trim().split("@")
        // The part before "@" can contain a ","
        // but we remove it on the domain part
        domain = domain.split(",")[0]
        return `${local}@${domain}`

        // You can also throw an error, which will redirect the user
        // to the sign-in page with error=EmailSignin in the URL
        // if (identifier.split("@").length > 2) {
        //   throw new Error("Only one email allowed")
        // }
      },
    }),
  ],
})
```

<Callout type="warning">
  务必确保该方法始终返回单个邮箱地址，即使传入了多个地址。
</Callout>
