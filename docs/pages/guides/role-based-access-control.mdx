import { Callout } from "nextra/components"
import { Code } from "@/components/Code"

# 基于角色的访问控制

使用 Auth.js 为应用程序添加[基于角色的访问控制(RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control)有两种方式，具体取决于您选择的[会话策略](/concepts/session-strategies)。我们将分别展示这两种方式的示例。

## 获取角色

首先在提供者配置中添加 `profile()` 回调函数来确定用户角色：

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Google from "next-auth/providers/google"

export const { handlers, auth } = NextAuth({
  providers: [
    Google({
      profile(profile) {
        return { role: profile.role ?? "user", ...profile }
      },
    }),
  ],
})
```

</Code.Next>
<Code.Qwik>
  
```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import Google from "@auth/qwik/providers/google"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [
      Google({
        profile(profile) {
          return { role: profile.role ?? "user", ...profile }
        },
      })
    ],
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts"
import SvelteKitAuth from "@auth/sveltekit"
import Google from "@auth/sveltekit/providers/google"

export const { handle } = SvelteKitAuth({
  providers: [
    Google({
      profile(profile) {
        return { role: profile.role ?? "user", ...profile }
      },
    }),
  ],
})
```

</Code.Svelte>
</Code>

<Callout>
  确定用户角色是您的责任，您可以添加自己的逻辑，或者如果您的提供者返回角色信息，也可以直接使用。
</Callout>

## 持久化角色

根据您使用的[会话策略](/concepts/session-strategies)，角色持久化的方式会有所不同。如果您不确定当前使用的会话策略，那么很可能使用的是默认的 JWT 策略。

### 使用 JWT

当未配置数据库时，角色将通过 `jwt()` 回调函数持久化到 cookie 中。在登录时，`profile` 回调中的 `user` 对象会暴露 `role` 属性。只需将 `user.role` 赋值给 `token.role` 即可完成持久化。

如果还需要在客户端使用角色信息，可以通过 `session` 回调函数进行暴露。

<Code>
<Code.Next>

```ts filename="./auth.ts" {8}
import NextAuth from "next-auth"
import Google from "next-auth/providers/google"

export const { handlers, auth } = NextAuth({
  providers: [
    Google({
      profile(profile) {
        return { role: profile.role ?? "user", ...profile }
      },
    }),
  ],
  callbacks: {
    jwt({ token, user }) {
      if (user) token.role = user.role
      return token
    },
    session({ session, token }) {
      session.user.role = token.role
      return session
    },
  },
})
```

</Code.Next>
<Code.Qwik>
  
```ts filename="/src/routes/plugin@auth.ts" {9}
import { QwikAuth$ } from "@auth/qwik"
import Google from "@auth/qwik/providers/google"

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [
      Google({
        profile(profile) {
          return { role: profile.role ?? "user", ...profile }
        },
      })
    ],
    callbacks: {
      jwt({ token, user }) {
        if(user) token.role = user.role
        return token
      },
      session({ session, token }) {
        session.user.role = token.role
        return session
      }
    }
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts" {8}
import SvelteKitAuth from "@auth/sveltekit"
import Google from "@auth/sveltekit/providers/google"

export const { handle } = SvelteKitAuth({
  providers: [
    Google({
      profile(profile) {
        return { role: profile.role ?? "user", ...profile }
      },
    }),
  ],
  callbacks: {
    jwt({ token, user }) {
      if (user) token.role = user.role
      return token
    },
    session({ session, token }) {
      session.user.role = token.role
      return session
    },
  },
})
```

</Code.Svelte>
</Code>

<Callout type="info">
  使用此策略时，如需更新角色信息，需要强制用户重新登录。
</Callout>

### 使用数据库

当您拥有数据库时，可以将用户角色保存在[User模型](/reference/core/adapters#adapteruser)上。以下示例展示了如何使用Prisma实现这一点，但该思路适用于所有适配器。

首先，在User模型中添加`role`列。

```prisma filename="/prisma/schema.prisma"
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  role          String?  // New column
  accounts      Account[]
  sessions      Session[]
}
```

`profile()`回调的返回值用于在数据库中创建用户。就这样！新创建的用户现在将拥有分配的角色。

如果您还想在客户端使用角色，可以通过`session`回调将其暴露出来。

<Code>
<Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Google from "next-auth/providers/google"
import prisma from "lib/prisma"

export const { handlers, auth } = NextAuth({
  adapter: PrismaAdapter(prisma),
  providers: [
    Google({
      profile(profile) {
        return { role: profile.role ?? "user", ...profile }
      },
    }),
  ],
  callbacks: {
    session({ session, user }) {
      session.user.role = user.role
      return session
    },
  },
})
```

</Code.Next>
<Code.Qwik>

```ts filename="/src/routes/plugin@auth.ts"
import { QwikAuth$ } from "@auth/qwik"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient()

export const { onRequest, useSession, useSignIn, useSignOut } = QwikAuth$(
  () => ({
    providers: [],
    adapter: PrismaAdapter(prisma),
    callbacks: {
      session({ session, user }) {
        session.user.role = user.role
        return session
      },
    },
  })
)
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./src/auth.ts"
import SvelteKitAuth from "@auth/sveltekit"
import Google from "@auth/sveltekit/providers/google"
import prisma from "lib/prisma"

export const { handle, auth } = SvelteKitAuth({
  adapter: PrismaAdapter(prisma),
  providers: [
    Google({
      profile(profile) {
        return { role: profile.role ?? "user", ...profile }
      },
    }),
  ],
  callbacks: {
    session({ session, user }) {
      session.user.role = user.role
      return session
    },
  },
})
```

```ts filename="src/hooks.server.ts"
export { handle } from "./auth"
```

</Code.Svelte>
</Code>

<Callout type="info">
  具体如何管理角色更新由您决定，可以通过直接数据库访问或构建自己的角色更新API来实现。
</Callout>

## 使用角色

用户可以通过从相应框架的配置文件中导出的授权函数访问当前会话中存储的信息。该函数会检索配置文件中通过`session`和`jwt`回调暴露的信息。利用这些信息，您可以根据需要实现不同的策略和逻辑来显示UI。

<Code>
<Code.Next>
To get the data on the server side, you should import the `auth` function from the configuration file and verify if the user has the expected role.

```ts filename="./app/admin/page.tsx"
import { auth } from "@/auth";

export default async function Page() {
  const session = await auth();

  if (session?.user?.role === "admin") {
    return <p>You are an admin, welcome!</p>;
  }

  return <p>You are not authorized to view this page!</p>;
}
```

</Code.Next>
<Code.NextClient>
If you want to use the role on the client side, use the `useSession` hook. The `session.user.role` will contain the required role if you exposed it via the `session` callback.

```ts filename="./app/admin/page.tsx"
"use client"
import { useSession } from "next-auth/react";

export default function Page() {
  const session = useSession();

  if (session?.user?.role === "admin") {
    return <p>You are an admin, welcome!</p>;
  }

  return <p>You are not authorized to view this page!</p>;
}
```

</Code.NextClient>
<Code.Qwik>

```ts filename="/src/routes/plugin@auth.ts"
export const onRequest: RequestHandler = (event) => {
  const session = event.sharedMap.get("session")
  if (!session || new Date(session.expires) < new Date()) {
    throw event.redirect(302, `/auth/signin?redirectTo=${event.url.pathname}`)
  }

  return session
}
```

</Code.Qwik>
<Code.Svelte>

```ts filename="./routes/+page.server.ts"
import { redirect } from "@sveltejs/kit"

export const load: PageServerLoad = async (event) => {
  const session = await event.locals.auth()

  if (!session && event.url.pathname !== "/login") {
    const fromUrl = event.url.pathname + event.url.search
    redirect(307, `/login?redirectTo=${encodeURIComponent(fromUrl)}`)
  }

  return {
    session,
  }
}
```

</Code.Svelte>
</Code>

<Callout>
  使用Next.js和JWT时，您也可以选择通过[中间件](/getting-started/session-management/protecting#nextjs-middleware)根据用户角色进行重定向，甚至在页面渲染之前完成。
</Callout>

## 相关资源

- [概念：会话策略](/concepts/session-strategies)
- [适配器：用户模型](/getting-started/database#user-model)
- [适配器：Prisma 适配器](/getting-started/adapters/prisma)
- [Next.js：中间件](/getting-started/session-management/protecting#nextjs-middleware)
- [TypeScript](/getting-started/typescript)
