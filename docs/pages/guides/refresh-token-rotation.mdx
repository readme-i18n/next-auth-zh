import { Code } from "@/components/Code"
import { Callout } from "nextra/components"

<Callout>
  截至目前，Auth.js
  尚未内置自动刷新令牌轮换的解决方案。本指南将帮助您在应用中实现此功能。我们的目标是为内置提供者最终添加零配置支持。如果您愿意参与贡献，[请告知我们](/contributors#core-team)。
</Callout>

## 什么是刷新令牌轮换？

刷新令牌轮换是指在不需用户交互（即重新认证）的情况下，代表用户更新 `access_token` 的实践方案。`access_token` 通常具有有限的有效期，过期后验证服务会将其视为无效。

许多提供者会在初始登录时同时颁发有效期更长的 `refresh_token`，避免要求用户重新登录来获取新的 `access_token`。Auth.js 库可配置为使用该 `refresh_token` 获取新的 `access_token`，而无需用户再次登录。

## 实现方案

<Callout type="info">
  以下指南存在一个固有局限，这是由于安全原因导致的：`refresh_token`
  通常只能使用一次。这意味着在成功刷新后，`refresh_token`
  将失效且无法再次使用。因此，在某些情况下，如果多个请求同时尝试刷新令牌，可能会发生竞态条件。Auth.js
  团队已意识到此问题，并计划在未来提供解决方案。可能的方案包括引入某种"锁定"机制来防止多个请求同时刷新令牌，但这会带来潜在的应用性能瓶颈问题。另一种可能的解决方案是后台令牌刷新，以防止在认证请求期间令牌过期。
</Callout>

首先，确保您要使用的提供商支持 `refresh_token`。更多详情请参阅 [OAuth 2.0 授权框架](https://www.rfc-editor.org/rfc/rfc6749#section-6)规范。
根据[会话策略](/concepts/session-strategies)的不同，`refresh_token` 可以保存在加密的 JWT cookie 中，也可以存储在数据库里。

### JWT 策略

<Callout>
  虽然使用 cookie 存储 `refresh_token` 更为简单，但安全性较低。为了降低
  `strategy: "jwt"` 的风险，Auth.js 库会将 `refresh_token` 存储在 _加密的_ JWT
  中，并置于 `HttpOnly` cookie 内。不过，您仍需根据实际需求评估选择哪种策略。
</Callout>

通过使用 [jwt](/reference/core/types#jwt) 和 [session](/reference/core/types#session) 回调，我们可以持久化 OAuth 令牌并在过期时进行刷新。

以下是通过 Google 刷新 `access_token` 的示例实现。请注意，获取 `refresh_token` 的 OAuth 2.0 请求会因提供商而异，但其余逻辑应保持相似。

<Code>
  <Code.Next>

```ts filename="./auth.ts"
import NextAuth, { type User } from "next-auth"
import Google from "next-auth/providers/google"

export const { handlers, auth } = NextAuth({
  providers: [
    Google({
      // Google requires "offline" access_type to provide a `refresh_token`
      authorization: { params: { access_type: "offline", prompt: "consent" } },
    }),
  ],
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        // First-time login, save the `access_token`, its expiry and the `refresh_token`
        return {
          ...token,
          access_token: account.access_token,
          expires_at: account.expires_at,
          refresh_token: account.refresh_token,
        }
      } else if (Date.now() < token.expires_at * 1000) {
        // Subsequent logins, but the `access_token` is still valid
        return token
      } else {
        // Subsequent logins, but the `access_token` has expired, try to refresh it
        if (!token.refresh_token) throw new TypeError("Missing refresh_token")

        try {
          // The `token_endpoint` can be found in the provider's documentation. Or if they support OIDC,
          // at their `/.well-known/openid-configuration` endpoint.
          // i.e. https://accounts.google.com/.well-known/openid-configuration
          const response = await fetch("https://oauth2.googleapis.com/token", {
            method: "POST",
            body: new URLSearchParams({
              client_id: process.env.AUTH_GOOGLE_ID!,
              client_secret: process.env.AUTH_GOOGLE_SECRET!,
              grant_type: "refresh_token",
              refresh_token: token.refresh_token!,
            }),
          })

          const tokensOrError = await response.json()

          if (!response.ok) throw tokensOrError

          const newTokens = tokensOrError as {
            access_token: string
            expires_in: number
            refresh_token?: string
          }

          return {
            ...token,
            access_token: newTokens.access_token,
            expires_at: Math.floor(Date.now() / 1000 + newTokens.expires_in),
            // Some providers only issue refresh tokens once, so preserve if we did not get a new one
            refresh_token: newTokens.refresh_token
              ? newTokens.refresh_token
              : token.refresh_token,
          }
        } catch (error) {
          console.error("Error refreshing access_token", error)
          // If we fail to refresh the token, return an error so we can handle it on the page
          token.error = "RefreshTokenError"
          return token
        }
      }
    },
    async session({ session, token }) {
      session.error = token.error
      return session
    },
  },
})

declare module "next-auth" {
  interface Session {
    error?: "RefreshTokenError"
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    access_token: string
    expires_at: number
    refresh_token?: string
    error?: "RefreshTokenError"
  }
}
```

  </Code.Next>
</Code>

### 数据库策略

使用数据库会话策略类似，但我们会将 `access_token`、`expires_at` 和 `refresh_token` 保存在对应提供商的 `account` 中。

<Code>
  <Code.Next>

```ts filename="./auth.ts"
import NextAuth from "next-auth"
import Google from "next-auth/providers/google"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient()

export const { handlers, signIn, signOut, auth } = NextAuth({
  adapter: PrismaAdapter(prisma),
  providers: [
    Google({
      authorization: { params: { access_type: "offline", prompt: "consent" } },
    }),
  ],
  callbacks: {
    async session({ session, user }) {
      const [googleAccount] = await prisma.account.findMany({
        where: { userId: user.id, provider: "google" },
      })
      if (googleAccount.expires_at * 1000 < Date.now()) {
        // If the access token has expired, try to refresh it
        try {
          // https://accounts.google.com/.well-known/openid-configuration
          // We need the `token_endpoint`.
          const response = await fetch("https://oauth2.googleapis.com/token", {
            method: "POST",
            body: new URLSearchParams({
              client_id: process.env.AUTH_GOOGLE_ID!,
              client_secret: process.env.AUTH_GOOGLE_SECRET!,
              grant_type: "refresh_token",
              refresh_token: googleAccount.refresh_token,
            }),
          })

          const tokensOrError = await response.json()

          if (!response.ok) throw tokensOrError

          const newTokens = tokensOrError as {
            access_token: string
            expires_in: number
            refresh_token?: string
          }

          await prisma.account.update({
            data: {
              access_token: newTokens.access_token,
              expires_at: Math.floor(Date.now() / 1000 + newTokens.expires_in),
              refresh_token:
                newTokens.refresh_token ?? googleAccount.refresh_token,
            },
            where: {
              provider_providerAccountId: {
                provider: "google",
                providerAccountId: googleAccount.providerAccountId,
              },
            },
          })
        } catch (error) {
          console.error("Error refreshing access_token", error)
          // If we fail to refresh the token, return an error so we can handle it on the page
          session.error = "RefreshTokenError"
        }
      }
      return session
    },
  },
})

declare module "next-auth" {
  interface Session {
    error?: "RefreshTokenError"
  }
}
```

  </Code.Next>
</Code>

### 错误处理

如果令牌刷新失败，我们可以强制重新进行身份验证。

<Code>

<Code.Next>

```tsx filename="app/dashboard/page.tsx"
import { auth, signIn } from "@/auth"

export default async function Page() {
  const session = await auth()
  if (session?.error === "RefreshTokenError") {
    await signIn("google") // Force sign in to obtain a new set of access and refresh tokens
  }
}
```

</Code.Next>

<Code.NextClient>

```tsx filename="app/dashboard/page.tsx"
"use client"

import { useEffect } from "react"
import { signIn, useSession } from "next-auth/react"

export default function Page() {
  const { data: session } = useSession() // For this to work, the Page should be wrapped inside the SessionProvider component in Layout
  useEffect(() => {
    if (session?.error !== "RefreshTokenError") return
    signIn("google") // Force sign in to obtain a new set of access and refresh tokens
  }, [session?.error])
}
```

</Code.NextClient>

</Code>
