# 测试

身份验证的重复一致性测试一直是个棘手问题。特别是 OAuth 提供商，在自动化测试中尤为困难，因为它们通常会引入额外的验证步骤——当从新地理位置、数据中心 IP 地址或新用户代理登录时就会触发这些验证。

为突破这些限制，我们推荐采用以下任一策略对 Auth.js 应用进行成功的端到端测试。

1. 使用 [Keycloak](https://www.keycloak.org) 等软件运行自己的 OAuth 提供商
2. 在开发模式下启用类似 Credentials provider 的认证方式

以下是每种策略的示例，均利用 [@playwright/test](https://playwright.dev) 进行自动化端到端测试。

## Keycloak

首先设置 [Keycloak](https://www.keycloak.org/getting-started/getting-started-docker) 实例，然后将 [Keycloak provider](/getting-started/providers/keycloak) 添加到 Auth.js 配置中。

该测试需要设置两个环境变量，这些凭证应属于能通过新建 Keycloak 实例认证的测试用户。

```bash filename=".env"
TEST_KEYCLOAK_USERNAME=abc
TEST_KEYCLOAK_PASSWORD=123
```

随后可使用 [`@playwright/test`](https://playwright.dev) 执行两个测试步骤。

1. 该操作将访问登录URL，输入认证凭据，然后点击"登录"按钮。确保会话随后被正确设置。
2. 该操作将点击"登出"按钮并确保会话随后变为`null`。

```ts filename="tests/e2e/basic-auth.spec.ts" {10, 32}
import { test, expect, type Page } from "@playwright/test"

test("Basic auth", async ({ page, browser }) => {
  if (
    !process.env.TEST_KEYCLOAK_USERNAME ||
    !process.env.TEST_KEYCLOAK_PASSWORD
  )
    throw new TypeError("Incorrect TEST_KEYCLOAK_{USERNAME,PASSWORD}")

  await test.step("should login", async () => {
    await page.goto("http://localhost:3000/auth/signin")
    await page.getByText("Keycloak").click()
    await page.getByText("Username or email").waitFor()
    await page
      .getByLabel("Username or email")
      .fill(process.env.TEST_KEYCLOAK_USERNAME)
    await page.locator("#password").fill(process.env.TEST_KEYCLOAK_PASSWORD)
    await page.getByRole("button", { name: "Sign In" }).click()
    await page.waitForURL("http://localhost:3000")
    const session = await page.locator("pre").textContent()

    expect(JSON.parse(session ?? "{}")).toEqual({
      user: {
        email: "bob@alice.com",
        name: "Bob Alice",
        image: "https://avatars.githubusercontent.com/u/67470890?s=200&v=4",
      },
      expires: expect.any(String),
    })
  })

  await test.step("should logout", async () => {
    await page.getByText("Sign out").click()
    await page
      .locator("header")
      .getByRole("button", { name: "Sign in", exact: true })
      .waitFor()
    await page.goto("http://localhost:3000/auth/session")

    expect(await page.locator("html").textContent()).toBe("null")
  })
})
```

## 开发环境中的`Credentials`提供程序

此方法需要较少的初始设置和维护工作，因为您无需维护单独的OAuth提供程序（如Keycloak），但您也必须格外小心，确保不会在生产环境中留下不安全的认证方法。例如，在本示例中我们将添加一个接受密码`password`的Credentials提供程序。

```ts filename="auth.ts" {16}
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
import Credentials from "next-auth/providers/credentials"

const providers = [GitHub]

if (process.env.NODE_ENV === "development") {
  providers.push(
    Credentials({
      id: "password",
      name: "Password",
      credentials: {
        password: { label: "Password", type: "password" },
      },
      authorize: (credentials) => {
        if (credentials.password === "password") {
          return {
            email: "bob@alice.com",
            name: "Bob Alice",
            image: "https://avatars.githubusercontent.com/u/67470890?s=200&v=4",
          }
        }
      },
    })
  )
}

export const { handlers, auth } = NextAuth({
  providers,
})
```

上述配置示例将始终添加GitHub提供程序，而`Credentials`提供程序仅在开发环境中启用。完成该配置调整后，我们就可以像上面那样编写`@playwright/test`测试了。

```ts filename="tests/e2e/basic-auth.spec.ts" {8}
import { test, expect, type Page } from "@playwright/test"

test("Basic auth", async ({ page, browser }) => {
  if (!process.env.TEST_PASSWORD) throw new TypeError("Missing TEST_PASSWORD")

  await test.step("should login", async () => {
    await page.goto("http://localhost:3000/auth/signin")
    await page.getByLabel("Password").fill(process.env.TEST_PASSWORD)
    await page.getByRole("button", { name: "Sign In" }).click()
    await page.waitForURL("http://localhost:3000")
    const session = await page.locator("pre").textContent()

    expect(JSON.parse(session ?? "{}")).toEqual({
      user: {
        email: "bob@alice.com",
        name: "Bob Alice",
        image: "https://avatars.githubusercontent.com/u/67470890?s=200&v=4",
      },
      expires: expect.any(String),
    })
  })

  await test.step("should logout", async () => {
    await page.getByText("Sign out").click()
    await page
      .locator("header")
      .getByRole("button", { name: "Sign in", exact: true })
      .waitFor()
    await page.goto("http://localhost:3000/auth/session")

    expect(await page.locator("html").textContent()).toBe("null")
  })
})
```
