import { Callout } from "nextra/components"

随着 Edge 运行时日益流行，开发者们自然希望在这些环境中部署 Auth.js 和 `next-auth`，但目前整个生态系统存在一些根本性的兼容性问题。我们希望通过本文档，无论您当前的理解程度和经验如何，都能帮助您认识这些挑战，并成功在所选运行时中运行 Auth.js！

首先，让我们先了解一些背景知识。如果您已熟悉这部分内容，可以直接跳过本节！

## 定义

我们将重点讨论 Auth.js 如何与当今各种框架、托管服务提供商、库等广泛使用的 [edge runtimes](https://runtime-compat.unjs.io) 进行交互。

首先，**什么是"edge"**？这里的"edge"概念源自网络工程领域，指的是位于网络边缘的计算节点（即服务器），也就是更靠近用户的设备。这类计算节点通常比数据中心核心区域运行关键工作负载的完整服务器性能更低。在此运行代码的优势包括：更低的用户端延迟、更好的可扩展性以及更具成本效益的计算资源。劣势则包括硬件性能较弱以及软件栈可能存在兼容性差异。

当我们提到<abbr title="通常运行在网络边缘（更靠近用户）的JavaScript执行环境，明确区别于Node.js，因此在代码运行方式等多个方面与我们惯用的Node.js环境存在差异">**edge runtimes**</abbr>时，指的是**非**Node.js的服务端JavaScript运行时，专为这些边缘计算节点（服务器）优化。这通常意味着代码会在更靠近用户的低功耗硬件上执行，这些硬件针对快速启动、低内存占用等特性进行了优化。

这是因为这些运行时环境通常缺少 Node.js 具备的功能特性，而这些特性有时对您依赖的库和包至关重要。当一个包声称"边缘兼容"或"边缘就绪"时，实际上意味着它们通过工程化设计避开了某些边缘运行时缺失的 Node.js 功能/模块，从而实现了更广泛的兼容性。您可以查看 unjs 的 [兼容性矩阵](https://runtime-compat.unjs.io) 了解不同运行时支持的功能特性。虽然这对 Auth.js 并非关键，但值得一提的是业界已成立 [WinterCG](https://wintercg.org) 工作组，旨在为 JavaScript 运行时提供 API 互操作性协作平台。

<Callout>
  需要说明的是，这些功能/模块的缺失通常是因为底层运行环境本身不支持。例如，无论开发者投入多少时间，如果他们的服务端
  JavaScript
  运行时运行在沙盒化的操作系统环境中且无法访问文件系统，那么无论如何努力都无法实现
  `fs` 模块。
</Callout>

由于当前 Node.js 与其他运行时环境的割裂状态和快速变化，许多库正在优化其工作负载以仅使用最通用的基础功能，例如 `fetch`。举例来说，如果您是数据库提供商，并且能够设计系统使客户端库仅需通过 HTTP 请求与后端通信，那么您就可以宣称自己的库具备"边缘兼容性"，能在用户所需的任何环境中运行。这与那些必须使用 Node.js 原始 TCP 套接字与后端通信的数据库客户端库形成鲜明对比。

## Auth.js

边缘兼容性是 Auth.js 重点优化的方向。这意味着您可以在任意 JavaScript 运行时环境中运行 Auth.js 的核心功能。但关键在于**核心功能**——如果您在 Auth.js 回调函数、中间件等场景中仅使用 Auth.js/`next-auth` 而不依赖其他库，那么它就能在任何地方运行！

当您尝试将其他库与 Auth.js 结合使用时，问题就开始显现。

## 问题所在

### 数据库适配器

与 Auth.js 搭配实现完整认证系统的常见组件是数据库客户端。数据库客户端的棘手之处在于它们通常利用 TCP 套接字直接与数据库服务器通信。PostgreSQL 就是采用这种方式的常见数据库之一。

PostgreSQL 是一种采用基于消息的协议进行客户端与服务器通信的数据库，该协议通过 **TCP（或 Unix）套接字**传输。原始 TCP 套接字属于 Node.js 中通常无法在边缘运行时使用的功能之一。因此从表面上看，似乎无法从运行在边缘运行时上的 JavaScript 与 PostgreSQL 数据库进行通信。许多其他数据库及其各自的通信协议也存在同样的问题。

然而随着边缘运行时的成熟和普及，人们发挥创造力，针对这一问题实现了多种解决方案。其中一个常见方案是在数据库前部署某种 API 服务器，其作用是将通过 HTTP 发送的数据库查询转换为数据库能理解的协议。这使得客户端只需向 API 服务器发起 HTTP 请求即可——这是所有边缘运行时都支持的功能。

### 中间件

在 Next.js 和 `next-auth` 中，您也可以使用 Next.js [中间件](https://nextjs.org/docs/app/building-your-application/routing/middleware)来保护路由，通过检查会话是否存在并决定下一步路由。默认情况下，在 Vercel 和其他托管平台上，**中间件代码始终在边缘运行时中执行**。这意味着我们的代码将尝试在底层功能不可用的环境（例如 TCP 套接字）中执行 PostgreSQL 查询等操作。因此，**要使用非明确"边缘兼容"的数据库适配器，我们需要找到一种方法，利用我们确实可用的功能来查询数据库**。

## 解决方案

Auth.js 与[数据库会话策略](/concepts/session-strategies#database-session)和数据库适配器一起使用时，在正常操作期间会多次调用数据库。无论您使用哪种框架，每个 Auth.js 客户端都可以获取当前活动会话，这是通过查询数据库来检查用户的 `sessionToken` 是否存在于数据库中且有效（即未过期）来实现的。

这意味着在应用程序中任何需要检查用户是否已认证的地方，都将触发数据库查询。实际上，Auth.js 在这方面更为智能，它会利用缓存和其他技巧来避免不必要的数据库请求，但可以想象每个 `auth()` 调用都可能触发一次数据库查询。因此，我们需要某种变通方案，才能在边缘运行时环境中使用 Auth.js 并兼容多种数据库适配器！

### 分离配置

考虑到 Next.js 和 `next-auth`，我们需要思考如何让 Auth.js 既能部分代码在边缘运行时执行，又能使用数据库存储会话。这需要为边缘环境准备一个不包含数据库设置的 `next-auth` "版本"，而其他场景则使用带数据库的版本。为此，我们可以利用 Auth.js 的["延迟初始化"](/reference/nextjs#lazy-initialization)特性：为中间件实例化一个不带适配器的独立客户端，另一个则用于其他所有场景。

1. 首先，创建一个通用的 Auth.js 配置对象供全局使用。该配置**不包含**数据库适配器。

```ts filename="auth.config.ts" /NextAuthConfig/
import GitHub from "next-auth/providers/github"
import type { NextAuthConfig } from "next-auth"

// Notice this is only an object, not a full Auth.js instance
export default {
  providers: [GitHub],
} satisfies NextAuthConfig
```

2. 接着，创建一个独立的**已实例化** Auth.js 实例，它导入上述配置但额外添加适配器，并使用 `jwt` 作为会话策略：

```ts filename="auth.ts" {2, 10, 11}
import NextAuth from "next-auth"
import authConfig from "./auth.config"

import { PrismaClient } from "@prisma/client"
import { PrismaAdapter } from "@auth/prisma-adapter"

const prisma = new PrismaClient()

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: { strategy: "jwt" },
  ...authConfig,
})
```

3. 我们的中间件随后会导入**不包含数据库适配器**的配置，并实例化自己的 Auth.js 客户端。

```ts filename="middleware.ts" {2, 4}
import NextAuth from "next-auth"
import authConfig from "./auth.config"

export const { auth: middleware } = NextAuth(authConfig)
```

4. 最后，在其他所有地方我们都可以从主 `auth.ts` 配置导入，并像往常一样使用 `next-auth`。更多示例请参阅我们的[会话管理文档](/getting-started/session-management/protecting)。

```tsx filename="app/protected/page.tsx" {4} /session/
import { auth } from "@/auth"

export default async function Page() {
  const session = await auth()

  if (!session) {
    return <div>Not authenticated</div>
  }

  return (
    <div className="container">
      <pre>{JSON.stringify(session, null, 2)}</pre>
    </div>
  )
}
```

这里需要特别注意的是，我们已经在中间件中移除了 `next-auth` 的**数据库功能和支持**。这意味着在执行中间件代码时，我们将无法获取会话或用户账户详情等其他信息。因此你需要依赖类似上面 `/app/protected/page.tsx` 文件中展示的检查逻辑，来确保[有效保护路由](/getting-started/session-management/protecting)。中间件仍可用于更新会话 cookie 的过期时间等操作。
